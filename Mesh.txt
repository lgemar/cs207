triangle_graph vs. connection graph
/** Create a triangle in the graph
* @pre no overlapping/crossing edges?
* @pre nodes have to be valid nodes in the graph
* @pre no more than 2 triangles can share an edge
* @returns a Triangle composed by the three nodes
Triangle add_triangle(Node n1, Node n2, Node n3);

n -> the normal to an edge, associated with edges
F -> associated with the edges in the direction of n
h -> associated with triangle

==> Adding a triangle
	: pass three nodes in the triangle graph
		--> each node needs to store all the triangles
			it's a part of
		--> If any two nodes are part of the same triangle
			then the added triangle shares an edges with
			that triangle and we need to draw a connection
			between the added triangle and the other triangle
			whose edge this new triangle is sharing
==> Storing and Accessing Information Related to each
	Triange, edge, and Node
	: Heights, edge integrals, normals, and forces are all
	  stored as node data in the connection graph
==> Accessing normal vectors
	: stored in the connection graph 
==> Accessing nodes of a triangles / edge
	: Each triangle has three node objects
==> Accessing adjacent triangles uses the connection graph
==> Accessing adjacent triangles of a node looks at the
	adjacency list of the node


1.) Defining a public interface for the Mesh class

class Triangle {
	Node node1()
	Node node2()
	Node node3()
	triangle_data value()
};

class TriangleIt {
	TriangleIter& operator++()
	Triangle operator*()
};

class Mesh {
	/** Create a node out of the given point */
	Node add_node(Point p)

	/** Add a triangle to the mesh defined by n1, n2, and n3 */
	Triangle add_triangle(Node n1, Node n2, Node n3)

	/** Return the triangle defined by n1, n2, and n3 */
	Triangle find_triangle(Node n1, Node n2, Node n3)

	/** Return the triangle with index i */
	Triangle find_triangle(size_t i)

	/** Return an iterator to all adjacent triangles */
	TriangleIt adjacent_triangles(Triangle t)

	/** Return an iterator to all adjacent triangles */
	TriangleIt adjacent_triangles(Node n)

	/** Return an iterator to the first triangle in the Mesh */
	TriangleIt triangle_begin()

	/** Return an iterator to the last triangle in the mesh */
	TriangeIt triangle_end()

	/** Find the normal vector from t1 to t2 */
	Point normal(Triangle t1, Triangle t2)

	/** Compute the normal vector to the edge */
	Point normal(Edge e)

	/** Compute the area of the triangle */
	double area(Triangle t)

	/** Find the ith node in the Mesh */
	Node node(size_t i)

	/** Return the edge specified by the given nodes */
	Edge edge(Node n1, Node n2)
};

2.) All operations are O(1) unless specified otherwise above.

3.) Abstraction Functions
AF( The ith Triangle in the Mesh ) = { 
	Triangle(v_1, v_2, v_3) | Triangle ti = connection_graph_->node(i) 
	and the jth vertex, Node v_j = connection_node(i).value().vj }

AF( Triangle with vertices v1, v2, v3 ) = {
	Triangle(v_1, v_2, v_3) | for Node j = v_1, v_2, v_3, 
	intersection( j.value().triangles() ) where j.value().triangles() is
	a set of triangles adjacent to the vertex represented by Node j }

4.) Representation of the Mesh class

5.) Representation Invariants

6.) Member data

The structs triangle_data, node_data, and edge_data structs
will hold the member data for triangles, nodes, and edges respectively.

typedef struct triangle_data {
	Node n1, n2, n3; // The nodes which make up the triangle
	double height; // The "height" of the column bounded by this triangle
} triangle_data;

typedef struct edge_data {
	Force force_vect; // Net force across the edge
	Point normal; // Normal vector across the edge
} edge_data;

typedef struct vertex_data {
	std::set<Triangle> faces_; // Adjacent triangles to the vertex
} vertex_data;




